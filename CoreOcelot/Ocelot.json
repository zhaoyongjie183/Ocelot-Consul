{
  //在配置文件中包含两个根节点：ReRoutes和GlobalConfiguration。
  //ReRoutes是一个数组，其中的每一个元素代表了一个路由，我们可以针对每一个路由进行以上功能配置。下面是一个完整的路由配置
  "ReRoutes": [
    {
      //Downstream是下游服务配置（表示要转发到的服务器端地址）
      //UpStream是上游服务配置 (表示用户端的输入)
      //Aggregates 服务聚合配置
      //ServiceName, LoadBalancer, UseServiceDiscovery 配置服务发现
      //AuthenticationOptions 配置服务认证
      //RouteClaimsRequirement 配置Claims鉴权
      //RateLimitOptions为限流配置
      //FileCacheOptions 缓存配置
      //QosOptions 服务质量与熔断
      //DownstreamHeaderTransform头信息转发
      "DownstreamPathTemplate": "/api/{url}",
      "DownstreamScheme": "https",
      //下游服务的地址，如果使用LoadBalancer的话这里可以填多项
      "DownstreamHostAndPorts": [
        {
          "Host": "localhost",
          "Port": 44353
        }
      ],
      //负载均衡配置
      //LoadBalancer将决定负载均衡的算法
      //1、LeastConnection C 将请求发往最空闲的那个服务器
      //2、RoundRobin C 轮流发送
      //3、NoLoadBalance C 总是发往第一个请求或者是服务发现
      //"LoadBalancer": "LeastConnection",
      "UpstreamPathTemplate": "/api/{url}",
      "UpstreamHttpMethod": [ "Get","Post" ]
      //权限验证
      //"AuthenticationOptions": {
      //  "AuthenticationProviderKey": "TestKey",
      //  "AllowedScopes": []
      //}
      //"Key": "orders"
    },
    {
      "DownstreamPathTemplate": "/api/products",
      "DownstreamScheme": "https",
      "DownstreamHostAndPorts": [
        {
          "Host": "localhost",
          "Port": 44354
        }
      ],
      "UpstreamPathTemplate": "/products",
      "UpstreamHttpMethod": [ "Get" ]
      //"Key": "products"
    }

  ],
  //请求聚合，当请求地址是http://localhose:XXXXX/的时候，会把两个reroute的数据一起返回
  //需要为reroute配置KEY使用
  //"Aggregates": [
  //  {
  //    "ReRouteKeys": [
  //      "orders",
  //      "products"
  //    ],
  //    "UpstreamPathTemplate": "/"
  //  }
  //],
  //全局请求设置
  "GlobalConfiguration": {
    "BaseUrl": "https://localhost:44350",
    "ServiceDiscoveryProvider": {
      "Host": "localhost",
      "Port": 8500,
      "Type": "Consul"
    }
  }
  //限流设置
  //ClientWihteList 白名单
  //EnableRateLimiting 是否启用限流
  //Period 统计时间段：1s, 5m, 1h, 1d
  //PeroidTimeSpan 多少秒之后客户端可以重试
  //Limit 在统计时间段内允许的最大请求数量
  //HttpStatusCode 当请求过载被截断时返回的http status
  //QuotaExceedMessage 当请求过载被截断时返回的消息
  //ClientIdHeader 用来识别客户端的请求头，默认是 ClientId
  //"RateLimitOptions": {
  //  "ClientWhitelist": [],
  //  "EnableRateLimiting": true,
  //  "Period": "1s",
  //  "PeriodTimespan": 1,
  //  "Limit": 1
  //},
  //服务质量与熔断
  //ExceptionsAllowedBeforeBreaking 允许多少个异常请求
  //DurationOfBreak 熔断的时间，单位为秒
  //TimeoutValue 如果下游请求的处理时间超过多少则自如将请求设置为超时
  //"QoSOptions": {
  //  "ExceptionsAllowedBeforeBreaking": 3,
  //  "DurationOfBreak": 5,
  //  "TimeoutValue": 5000
  //},
  //缓存
  //"FileCacheOptions": {
  //  "TtlSeconds": 15,
  //  "Region": "somename"
  //},
  ///"UseServiceDiscovery": false //使用服务发现，目前Ocelot只支持Consul的服务发现
}